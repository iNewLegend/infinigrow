/**
 * This a POC, made during the assignment, comments generated by github copilot.
 */
import commandsManager from "@infinigrow/commander/commands-manager";

import { APIModuleBase } from "@infinigrow/api/src/api-module-base.ts";

import { CHANNEL_LIST_STATE_DATA_WITH_META } from "@infinigrow/demo-app/src/components/channel/channel-constants";

import { pickEnforcedKeys } from "@infinigrow/demo-app/src/utils";

import "@infinigrow/demo-app/src/api/api-fake-data";

import type { APIComponent } from "@infinigrow/api/src/api-component.tsx";

import type { CommandFunctionComponent, CommandSingleComponentContext } from "@infinigrow/commander/types";

import type { APICore } from "@infinigrow/api/src/api-core.tsx";

export class APIChannelsModule extends APIModuleBase {
    private channelsListState: Record<string, any> = {};
    private channelsItemState: Record<string, any> = {};
    private lastChannelsItemState: Record<string, any> = {};

    private autosaveDebounceTimer: Timer | undefined;
    private autosaveHandler: ( ( immediate?: boolean ) => boolean ) | undefined;

    public constructor( api: APICore ) {
        super( api );

        this.registerEndpoints();

        const dataRescuerCallback = () => {
            console.log( "APIChannelsModule: dataRescuerCallback()", {
                autoSaveHandler: this.autosaveHandler,
            } );

            if ( this.autosaveHandler ) {
                // Save immediately when the page is closed.
                return this.autosaveHandler( true );
            }
        };

        window.onbeforeunload = function () {
            const result = dataRescuerCallback();

            if ( ! result ) {
                return "Changes you made may not be saved.";
            }

            return undefined;
        };
    }

    public static getName(): string {
        return "channels";
    }

    private registerEndpoints(): void {
        this.register( "GET", "App/ChannelsList", "v1/channels" );
        this.register( "GET", "App/ChannelItem", "v1/channels/:key" );
        this.register( "POST", "App/ChannelItem", "v1/channels/:key" );
    }

    protected async requestHandler( component: APIComponent, element: CommandFunctionComponent, request: any ): Promise<any> {
        return request;
    }

    protected async responseHandler( component: APIComponent, element: CommandFunctionComponent, response: Response ): Promise<any> {
        const result = await response.json();
        return this.handleResponseBasedOnElementName( element.getName!(), result, component );
    }

    // Handle the mounting of the component. This involves different handling depending on the component name.
    protected onMount( component: APIComponent, context: CommandSingleComponentContext ) {
        switch ( context.componentName ) {
            case "App/ChannelsList":
                this.onChannelsListMount( component, context );
                break;
            case "App/ChannelItem":
                this.onChannelItemMount( component, context );
                break;
            default:
                throw new Error( `APIChannelsModule: onMount() - Unknown component: ${ context.componentName }` );
        }
    }

    protected onUnmount( component: APIComponent, context: CommandSingleComponentContext ) {
        switch ( context.componentName ) {
            case "App/ChannelsList":
                this.onChannelsListUnmount( component, context );
                break;
            case "App/ChannelItem":
                this.onChannelItemUnmount( component, context );
                break;
            default:
                throw new Error( `APIChannelsModule: onUnmount() - Unknown component: ${ context.componentName }` );
        }
    }

    // Handle the updating of the component. This involves different handling depending on the component name.
    protected onUpdate( component: APIComponent, context: CommandSingleComponentContext, state: {
        currentState: any,
        prevState: any,
        currentProps: any
    } ) {
        const { currentState, prevState } = state;
        switch ( context.componentName ) {
            case "App/ChannelsList":
                this.channelsListState = state;
                if ( currentState.channels !== prevState.channels ) {
                    this.onChannelsChanged( prevState.channels, currentState.channels );
                }
                break;
            case "App/ChannelItem":
                this.channelsItemState[ state.currentProps.$$api_$key$$ ] = state;
                this.lastChannelsItemState[ state.currentProps.$$api_$key$$ ] = state;
                break;
            default:
                throw new Error( `APIChannelsModule: onUpdate() - Unknown component: ${ context.componentName }` );
        }
    }

    private initializeAutosaveHandler( context: CommandSingleComponentContext, component: APIComponent ) {
        if ( ! this.autosaveHandler ) {
            this.autosaveHandler = ( immediate?: boolean ) => {
                if ( immediate ) {
                    this.saveChannels( component, context );
                    return true;
                } else {
                    this.autoSaveChannels( component, context );
                }

                return false;
            };
        }

        const timer = setInterval( () => {
            if ( ! context.isMounted() ) {
                this.autosaveHandler = undefined;
                clearInterval( timer );
                return;
            }

            this.autosaveHandler?.();
        }, 5000 );
    }

    // Handle the API response based on the element name. This allows different handling for different types of responses.
    private handleResponseBasedOnElementName( elementName: string, result: any, component: APIComponent ) {
        switch ( elementName ) {
            case "App/ChannelsList":
                return this.handleChannelsListResponse( result, component );
            case "App/ChannelItem":
                return this.handleChannelItemResponse( result );
            default:
                return result;
        }
    }

    // Handle the response for the channels list. This involves mapping over the result and creating a new object for each item.
    private handleChannelsListResponse( result: any, component: APIComponent ) {
        return {
            children: result.map( ( i: any ) => {
                const key = i.key;
                delete i.key;
                return {
                    key,
                    props: i,
                    type: component.props.children!.props.type,
                    $$api_$key$$: key,
                };
            } ),
        };
    }

    // Handle the response for an individual channel item. This involves creating a new object with the key and breaks properties modified.
    private handleChannelItemResponse( result: any ) {
        result.$$api_$key$$ = result.key;
        if ( result.breaks ) {
            result.breaks = result.breaks.map( ( i: any ) => ( {
                ... i,
                date: new Date( i.date ),
            } ) );
        }
        return result;
    }

    // Handle the mounting of the channels list. This involves setting up a timer to auto save channels every 5 seconds.
    private onChannelsListMount( component: APIComponent, context: CommandSingleComponentContext ) {
        const commands = commandsManager.get( "UI/Accordion" );

        const onSelectionAttached = commands[ "UI/Accordion/onSelectionAttached" ],
            onSelectionDetached = commands[ "UI/Accordion/onSelectionDetached" ];

        const saveChannelsCallback = () => {
            this.autoSaveChannels( component, context );
        };

        onSelectionAttached.global().globalHook( saveChannelsCallback );
        onSelectionDetached.global().globalHook( saveChannelsCallback );

        this.initializeAutosaveHandler( context, component );
    }

    private onChannelsListUnmount( component: APIComponent, context: CommandSingleComponentContext ) {
        // Save immediately when the channels list is unmounted.
        this.saveChannels( component, context );

        const commands = commandsManager.get( "UI/Accordion" );

        const onSelectionAttached = commands[ "UI/Accordion/onSelectionAttached" ],
            onSelectionDetached = commands[ "UI/Accordion/onSelectionDetached" ];

        onSelectionAttached.global().globalUnhook();
        onSelectionDetached.global().globalUnhook();
    }

    // Handle the mounting of an individual channel item. This involves fetching the channel data from the API and updating the state if necessary.
    private async onChannelItemMount( component: APIComponent, context: CommandSingleComponentContext ) {
        if ( Object.keys( this.channelsItemState ).length === 0 ) return;
        if ( Object.keys( this.channelsListState ).length === 0 ) return;

        const key = this.getKeyFromContext( context );

        try {
            const apiData = await this.fetchAPIGetChannel( key );

            if ( context.isMounted() && this.shouldUpdateState( apiData, key, context ) ) {
                this.updateState( apiData, context );
            }

        } catch ( error ) {
            console.error( "An error occurred while fetching API data", error );
        }
    }

    private async onChannelItemUnmount( component: APIComponent, context: CommandSingleComponentContext ) {
        this.autosaveHandler?.();
    }

    // Handle when the channels change. This involves comparing the previous and current channels and updating the meta data if necessary.
    private onChannelsChanged( prevChannels: any[], currentChannels: any[] ) {
        const prevKeys = prevChannels.map( channel => channel.key );
        const currentKeys = currentChannels.map( channel => channel.key );

        const addedKeys = currentKeys.filter( key => ! prevKeys.includes( key ) );

        for ( const key of addedKeys ) {
            const newChannel = currentChannels.find( channel => channel.key === key );

            if ( newChannel && newChannel.props && newChannel.props.meta ) {
                this.onChannelAdded( newChannel );
            }
        }
        if ( addedKeys.length > 0 ) {
            return;
        }

        const removedKeys = prevKeys.filter( key => ! currentKeys.includes( key ) );
        for ( const key of removedKeys ) {
            this.onChannelRemoved( key );
        }
        if ( removedKeys.length > 0 ) {
            return;
        }

        for ( let i = 0 ; i < currentChannels.length ; i++ ) {
            if ( ! prevChannels[ i ] || ! currentChannels[ i ] ) continue;
            if ( prevChannels[ i ].props.meta !== currentChannels[ i ].props.meta ) {
                this.onChannelsMetaDataChanged( prevChannels[ i ].key!, prevChannels[ i ].props.meta, currentChannels[ i ].props.meta );
            }
        }
    }

    private onChannelAdded( newChannel: any ) {
        // Add the new channel to the channelsItemState object
        this.channelsItemState[ newChannel.key ] = newChannel;

        // Send a POST request to the API to create the new channel
        this.api.fetch( "POST", `v1/channels/${ newChannel.key }`, {
            key: newChannel.key,
            meta: newChannel.props.meta,
        }, ( r: {
            json: () => any;
        } ) => r.json() );
    }

    private onChannelRemoved( key: string ) {
        this.api.fetch( "DELETE", `v1/channels/${ key }`, {}, ( r: { json: () => any; } ) => r.json() );

        delete this.channelsItemState[ key ];
    }

    // Handle when the meta data of a channel changes. This involves sending a POST request to the API with the new meta data.
    private onChannelsMetaDataChanged( key: string, prevMeta: any, currentMeta: any ) {
        this.api.fetch( "POST", "v1/channels/:key", { key, meta: currentMeta }, ( r: {
            json: () => any;
        } ) => r.json() );
    }

    private async autoSaveChannels( component: APIComponent, channelsListComponentContext: CommandSingleComponentContext ): Promise<true> {
        if ( this.autosaveDebounceTimer ) {
            clearTimeout( this.autosaveDebounceTimer );
        }

        // This will ensure that the channels are saved once per x requests during the debounce period.
        return new Promise( ( resolve ) => {
            this.autosaveDebounceTimer = setTimeout( () => {
                this.saveChannels( component, channelsListComponentContext );
                resolve( true );
            }, 800 );
        } );
    }

    // Save the channels. This involves finding all the channel item contexts and sending a POST request to the API with the state of each channel.
    private saveChannels( component: APIComponent, context: CommandSingleComponentContext ) {
        console.log( "APIChannelsModule: saveChannels() for component: ", context.componentNameUnique );

        const lastKnownStates = Object.values( this.lastChannelsItemState );

        try {
            lastKnownStates.forEach( ( state: any ) => {
                const key = state.currentProps.$$api_$key$$;

                const stateToSave = pickEnforcedKeys( { ... state.currentProps, ... state.currentState },
                    CHANNEL_LIST_STATE_DATA_WITH_META
                );

                this.api.fetch( "POST", "v1/channels/:key", { key, ... stateToSave }, ( r: {
                    json: () => any;
                } ) => r.json() );
            } );
        } catch ( error ) {
            console.warn( "An error occurred while saving channels, autoSave is reschedule!", error );

            this.autoSaveChannels( component, context );
        }

    }

    // Update the state with the data from the API.
    private updateState( apiData: any, context: CommandSingleComponentContext ) {
        if ( apiData.breaks ) {
            apiData.breaks = apiData.breaks.map( ( i: any ) => ( {
                ... i,
                date: new Date( i.date ),
            } ) );
        }

        context.setState( apiData );
    }

    // Determine whether the state should be updated. This involves comparing the current state with the data from the API.
    private shouldUpdateState( apiData: any, key: string, context: CommandSingleComponentContext ) {
        const currentItemState = this.channelsItemState[ key ];

        const vdom = pickEnforcedKeys( { ... currentItemState.currentProps, ... context.getState() },
            CHANNEL_LIST_STATE_DATA_WITH_META
        );

        const api = pickEnforcedKeys( apiData, CHANNEL_LIST_STATE_DATA_WITH_META );

        return JSON.stringify( vdom ) !== JSON.stringify( api );
    }

    // Get the key from the context. This involves finding the channel with the same id as the context's props.
    private getKeyFromContext( context: CommandSingleComponentContext ) {
        return this.channelsListState.currentState.channels.find( ( i: any ) => i.meta.id === context.props.meta.id ).key;
    }

    // Fetch the channel data from the API.
    private async fetchAPIGetChannel( key: string ) {
        return await this.api.fetch( "GET", `v1/channels/${ key }`, {}, ( res: { json: () => any; } ) => res.json() );
    }

}

