/**
 * This a POC, made during the assignment, comments generated by github copilot.
 */
import core from "@infinigrow/commander/core";

import commandsManager from "@infinigrow/commander/commands-manager";

import { GET_INTERNAL_SYMBOL } from "@infinigrow/commander/constants";

import { APIModuleBase } from "@infinigrow/api/src/api-module-base.ts";

import {
    CHANNEL_LIST_STATE_DATA,
    CHANNEL_LIST_STATE_DATA_WITH_META
} from "@infinigrow/demo-app/src/components/channel/channel-consts";

import { pickEnforcedKeys } from "@infinigrow/demo-app/src/utils";

import "@infinigrow/demo-app/src/api/api-fake-data";

import type { APIComponent } from "@infinigrow/api/src/api-component.tsx";

import type { CommandFunctionComponent, CommandSingleComponentContext } from "@infinigrow/commander/types";

import type { APICore } from "@infinigrow/api/src/api-core.tsx";

export class APIChannelsModule extends APIModuleBase {
    private channelsListState: Record<string, any> = {};
    private channelsItemState: Record<string, any> = {};

    private channelsListMountOnce = false;
    private autosaveHandler: ( () => void ) | undefined;

    public constructor( api: APICore ) {
        super( api );

        this.registerEndpoints();

        window.addEventListener("beforeunload", () => {
            if ( this.autosaveHandler ) {
                this.autosaveHandler();
            }
        } );
    }

    public static getName(): string {
        return "channels";
    }

    private registerEndpoints(): void {
        this.register( "GET", "App/ChannelsList", "v1/channels" );
        this.register( "GET", "App/ChannelItem", "v1/channels/:key" );
        this.register( "POST", "App/ChannelItem", "v1/channels/:key" );
    }

    protected async requestHandler( component: APIComponent, element: CommandFunctionComponent, request: any ): Promise<any> {
        return request;
    }

    protected async responseHandler( component: APIComponent, element: CommandFunctionComponent, response: Response ): Promise<any> {
        const result = await response.json();
        return this.handleResponseBasedOnElementName( element.getName!(), result, component );
    }

    // Handle the API response based on the element name. This allows different handling for different types of responses.
    private handleResponseBasedOnElementName( elementName: string, result: any, component: APIComponent ) {
        switch ( elementName ) {
            case "App/ChannelsList":
                return this.handleChannelsListResponse( result, component );
            case "App/ChannelItem":
                return this.handleChannelItemResponse( result );
            default:
                return result;
        }
    }

    // Handle the response for the channels list. This involves mapping over the result and creating a new object for each item.
    private handleChannelsListResponse( result: any, component: APIComponent ) {
        return {
            children: result.map( ( i: any ) => {
                const key = i.key;
                delete i.key;
                return {
                    key,
                    props: i,
                    type: component.props.children!.props.type,
                    $$api_$key$$: key,
                };
            } ),
        };
    }

    // Handle the response for an individual channel item. This involves creating a new object with the key and breaks properties modified.
    private handleChannelItemResponse( result: any ) {
        result.$$api_$key$$ = result.key;
        if ( result.breaks ) {
            result.breaks = result.breaks.map( ( i: any ) => ( {
                ... i,
                date: new Date( i.date ),
            } ) );
        }
        return result;
    }

    // Handle the mounting of the component. This involves different handling depending on the component name.
    protected onMount( component: APIComponent, context: CommandSingleComponentContext ) {
        switch ( context.componentName ) {
            case "App/ChannelsList":
                this.onChannelsListMount( component, context );
                break;
            case "App/ChannelItem":
                this.onChannelItemMount( component, context );
                break;
            default:
                throw new Error( `APIChannelsModule: onMount() - Unknown component: ${ context.componentName }` );
        }
    }

    // Handle the updating of the component. This involves different handling depending on the component name.
    protected onUpdate( component: APIComponent, context: CommandSingleComponentContext, state: {
        currentState: any,
        prevState: any,
        currentProps: any
    } ) {
        const { currentState, prevState } = state;
        switch ( context.componentName ) {
            case "App/ChannelsList":
                this.channelsListState = state;
                if ( currentState.channels !== prevState.channels ) {
                    this.onChannelsChanged( prevState.channels, currentState.channels );
                }
                break;
            case "App/ChannelItem":
                this.channelsItemState[ state.currentProps.$$api_$key$$ ] = state;
                break;
            default:
                throw new Error( `APIChannelsModule: onUpdate() - Unknown component: ${ context.componentName }` );
        }
    }

    // Handle the mounting of the channels list. This involves setting up a timer to auto save channels every 5 seconds.
    private onChannelsListMount( component: APIComponent, context: CommandSingleComponentContext ) {
        if ( ! this.channelsListMountOnce ) {
            this.channelsListMountOnce = true;
            this.onChannelListMountOnce( component, context );
        }

        this.initializeAutosaveHandler( context, component );
    }

    private initializeAutosaveHandler( context: CommandSingleComponentContext, component: APIComponent ) {
        const timer = setInterval( () => {
            if ( ! context.isMounted() ) {
                clearInterval( timer );
                return;
            }

            if ( ! this.autosaveHandler ) {
                this.autosaveHandler = this.onAutoSaveChannels.bind( this, component, context );
            }

            this.autosaveHandler();
        }, 5000 );
    }

// Handle the mounting of an individual channel item. This involves fetching the channel data from the API and updating the state if necessary.
    private async onChannelItemMount( component: APIComponent, context: CommandSingleComponentContext ) {
        if ( Object.keys( this.channelsItemState ).length === 0 ) return;

        const key = this.getKeyFromContext( context );

        try {
            const apiData = await this.fetchAPIGetChannel( key );

            if ( this.shouldUpdateState( apiData, key, context ) ) {
                this.updateState( apiData, context );
            }

        } catch ( error ) {
            console.error( "An error occurred while fetching API data", error );
        }
    }

    // Get the key from the context. This involves finding the channel with the same id as the context's props.
    private getKeyFromContext( context: CommandSingleComponentContext ) {
        return this.channelsListState.currentState.channels.find( ( i: any ) => i.meta.id === context.props.meta.id ).key;
    }

    // Fetch the channel data from the API.
    private async fetchAPIGetChannel( key: string ) {
        return await this.api.fetch( "GET", `v1/channels/${ key }`, {}, ( res: { json: () => any; } ) => res.json() );
    }

    // Determine whether the state should be updated. This involves comparing the current state with the data from the API.
    private shouldUpdateState( apiData: any, key: string, context: CommandSingleComponentContext ) {
        const currentItemState = this.channelsItemState[ key ];

        const vdom = pickEnforcedKeys( { ... currentItemState.currentProps, ... context.getState() },
            CHANNEL_LIST_STATE_DATA_WITH_META
        );

        const api = pickEnforcedKeys( apiData, CHANNEL_LIST_STATE_DATA_WITH_META );

        return JSON.stringify( vdom ) !== JSON.stringify( api );
    }

    // Update the state with the data from the API.
    private updateState( apiData: any, context: CommandSingleComponentContext ) {
        if ( apiData.breaks ) {
            apiData.breaks = apiData.breaks.map( ( i: any ) => ( {
                ... i,
                date: new Date( i.date ),
            } ) );
        }

        context.setState( apiData );
    }

    // Handle the first time the channels list is mounted. This involves setting up hooks for when the selection is attached or detached.
    private onChannelListMountOnce( component: APIComponent, context: CommandSingleComponentContext ) {
        const commands = commandsManager.get( "UI/Accordion" );

        const onSelectionAttached = commands[ "UI/Accordion/onSelectionAttached" ],
            onSelectionDetached = commands[ "UI/Accordion/onSelectionDetached" ];

        onSelectionAttached.global().globalHook( () => {
            this.saveChannels( component, context );
        } );

        onSelectionDetached.global().globalHook( () => {
            this.saveChannels( component, context );
        } );
    }

    // Handle when the channels change. This involves comparing the previous and current channels and updating the meta data if necessary.
    private onChannelsChanged( prevChannels: any[], currentChannels: any[] ) {
        for ( let i = 0 ; i < currentChannels.length ; i++ ) {
            if ( prevChannels[ i ].props.meta !== currentChannels[ i ].props.meta ) {
                this.onChannelsMetaDataChanged( prevChannels[ i ].key!, prevChannels[ i ].props.meta, currentChannels[ i ].props.meta );
                break;
            }
        }

        const prevKeys = prevChannels.map(channel => channel.key);
        const currentKeys = currentChannels.map(channel => channel.key);

        const removedKeys = prevKeys.filter(key => !currentKeys.includes(key));

        for ( const key of removedKeys ) {
            this.onChannelRemoved( key );
        }
    }

    private onChannelRemoved( key: string ) {
        this.api.fetch( "DELETE", `v1/channels/${ key }`, {}, ( r: { json: () => any; } ) => r.json() );

        delete this.channelsItemState[ key ];
    }

    // Handle when the meta data of a channel changes. This involves sending a POST request to the API with the new meta data.
    private onChannelsMetaDataChanged( key: string, prevMeta: any, currentMeta: any ) {
        this.api.fetch( "POST", "v1/channels/:key", { key, meta: currentMeta }, ( r: { json: () => any; } ) => r.json() );
    }

    // Save the channels. This involves finding all the channel item contexts and sending a POST request to the API with the state of each channel.
    private saveChannels( component: APIComponent, context: CommandSingleComponentContext ) {
        const componentContext = context.getComponentContext();

        const findChannelItemContexts = ( currentContext: typeof componentContext ): typeof componentContext[] => {
            let channelItemContexts = [];

            if ( currentContext.getComponentName() === "App/ChannelItem" ) {
                channelItemContexts.push( currentContext );
            }

            for ( const childContext of Object.values( currentContext.children || {} ) ) {
                channelItemContexts = channelItemContexts.concat( findChannelItemContexts( childContext ) );
            }

            return channelItemContexts;
        };

        const channelItemContexts = findChannelItemContexts( componentContext );

        for ( const channelItemContext of channelItemContexts ) {
            const currentNameUnique = channelItemContext.getNameUnique();

            if ( ! commandsManager.isContextRegistered( currentNameUnique ) ) {
                continue;
            }

            const internalContext = core[ GET_INTERNAL_SYMBOL ]( currentNameUnique );

            const state = internalContext.getState();

            const key = context.getState<any>().channels.find( ( i: any ) => i.meta.id === internalContext.props.meta.id ).key;

            const stateToSave = pickEnforcedKeys( state, CHANNEL_LIST_STATE_DATA );

            this.api.fetch( "POST", "v1/channels/:key", { key, ... stateToSave }, ( r: { json: () => any; } ) => r.json() );
        }
    }

    private onAutoSaveChannels( component: APIComponent, context: CommandSingleComponentContext ) {
        this.saveChannels( component, context );
    }
}

